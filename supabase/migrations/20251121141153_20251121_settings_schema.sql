-- Migration: Settings Page Schema
-- Description: Adds tables for Subscriptions, User Settings, Pricing Plans, Payments, Billing, and Refunds.
-- Strategy: ZERO BREAKING CHANGES. No ALTER to existing tables. Syncs to user_quotas via triggers.

-- 1. Enable UUID extension if not exists (standard for Supabase)
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 2. Subscriptions Table (Billing Layer)
CREATE TABLE IF NOT EXISTS subscriptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  master_user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
  
  -- Plan Info
  plan_type TEXT NOT NULL DEFAULT 'free' CHECK (plan_type IN ('free', 'basic', 'pro')),
  billing_cycle TEXT DEFAULT 'monthly' CHECK (billing_cycle IN ('monthly', 'yearly')),
  status TEXT DEFAULT 'active' CHECK (status IN ('active', 'expired', 'cancelled', 'pending')),
  
  -- Pricing
  price DECIMAL(10,2) DEFAULT 0,
  currency TEXT DEFAULT 'IDR',
  
  -- Dates
  valid_from TIMESTAMPTZ DEFAULT NOW(),
  valid_until TIMESTAMPTZ,
  next_billing_date TIMESTAMPTZ,
  quota_reset_date TIMESTAMPTZ DEFAULT DATE_TRUNC('month', NOW() + INTERVAL '1 month'),
  
  -- Auto-renewal
  auto_renew BOOLEAN DEFAULT false,
  
  -- Scheduled Changes
  scheduled_downgrade_to TEXT,
  scheduled_downgrade_date TIMESTAMPTZ,
  
  -- Grace Period
  grace_period_ends_at TIMESTAMPTZ,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- RLS for subscriptions
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own subscription" ON subscriptions FOR SELECT USING (auth.uid() = master_user_id);
CREATE POLICY "Users can update own subscription" ON subscriptions FOR UPDATE USING (auth.uid() = master_user_id);

-- 3. User Settings Table
CREATE TABLE IF NOT EXISTS user_settings (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  language TEXT DEFAULT 'id' CHECK (language IN ('id', 'en')),
  timezone TEXT DEFAULT 'Asia/Jakarta',
  theme TEXT DEFAULT 'light' CHECK (theme IN ('light', 'dark', 'system')),
  enable_push_notifications BOOLEAN DEFAULT true,
  enable_email_notifications BOOLEAN DEFAULT false,
  api_key TEXT, -- Read-only in UI, generated by system if needed
  webhook_url TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- RLS for user_settings
ALTER TABLE user_settings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own settings" ON user_settings FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can update own settings" ON user_settings FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own settings" ON user_settings FOR INSERT WITH CHECK (auth.uid() = user_id);

-- 4. Sync Trigger: When Subscription Changes -> Update User Quotas
CREATE OR REPLACE FUNCTION sync_subscription_to_quota() 
RETURNS TRIGGER AS $$
DECLARE
  v_limit INTEGER;
  v_reset_date TIMESTAMPTZ;
BEGIN
  -- Determine limit based on plan
  IF NEW.plan_type = 'free' THEN
    v_limit := 5;
  ELSIF NEW.plan_type = 'basic' THEN
    v_limit := 500;
  ELSIF NEW.plan_type = 'pro' THEN
    v_limit := 999999;
  ELSE
    v_limit := 5; -- Fallback
  END IF;

  -- Update user_quotas
  -- Using ON CONFLICT logic equivalent since user_quotas PK is id, but we search by user_id
  UPDATE user_quotas 
  SET 
    plan_type = NEW.plan_type,
    messages_limit = v_limit,
    updated_at = NOW()
  WHERE user_id = NEW.master_user_id;
  
  -- If no quota exists (unlikely given previous migrations, but safe)
  IF NOT FOUND THEN
    INSERT INTO user_quotas (user_id, master_user_id, plan_type, messages_limit, messages_used, reset_date)
    VALUES (NEW.master_user_id, NEW.master_user_id, NEW.plan_type, v_limit, 0, NEW.quota_reset_date);
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_subscription_change
AFTER INSERT OR UPDATE ON subscriptions
FOR EACH ROW EXECUTE FUNCTION sync_subscription_to_quota();

-- 5. Pricing Plans Table (Catalog)
CREATE TABLE IF NOT EXISTS pricing_plans (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  plan_type TEXT NOT NULL, -- free, basic, pro
  plan_name TEXT NOT NULL UNIQUE, -- Basic Monthly, Pro Yearly
  billing_cycle TEXT NOT NULL, -- monthly, yearly
  price DECIMAL(10,2) NOT NULL,
  quota INTEGER NOT NULL,
  features JSONB DEFAULT '[]',
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- RLS for pricing_plans (Public Read-only)
ALTER TABLE pricing_plans ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public read pricing" ON pricing_plans FOR SELECT USING (true);


-- 6. Payment Transactions Table (extends payments unique handling)
-- NOTE: We already have 'payments' table. To avoid conflict/mess, we create 'payment_transactions' 
-- which is more robust for Xendit/Midtrans callback handling.
CREATE TABLE IF NOT EXISTS payment_transactions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  external_id TEXT UNIQUE NOT NULL, -- Xendit Invoice ID
  amount DECIMAL(10,2) NOT NULL,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'paid', 'expired', 'failed')),
  payment_method TEXT,
  payment_channel TEXT, -- BCA, BNI, OVO
  paid_at TIMESTAMPTZ,
  expiry_date TIMESTAMPTZ,
  payment_url TEXT,
  
  -- Metadata
  plan_id UUID REFERENCES pricing_plans(id),
  subscription_id UUID REFERENCES subscriptions(id),
  description TEXT,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- RLS: Users view own
ALTER TABLE payment_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own transactions" ON payment_transactions FOR SELECT USING (auth.uid() = user_id);

-- 7. Billing Information Table (for Invoice)
CREATE TABLE IF NOT EXISTS billing_information (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
  
  name TEXT,
  company_name TEXT,
  address TEXT,
  city TEXT,
  postal_code TEXT,
  country TEXT DEFAULT 'Indonesia',
  tax_id TEXT, -- NPWP
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- RLS for billing_information
ALTER TABLE billing_information ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own billing info" ON billing_information FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can update own billing info" ON billing_information FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own billing info" ON billing_information FOR INSERT WITH CHECK (auth.uid() = user_id);

-- 8. Refund Requests Table
CREATE TABLE IF NOT EXISTS refund_requests (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  transaction_id UUID REFERENCES payment_transactions(id),
  
  refund_number TEXT UNIQUE NOT NULL, -- REF-YYYY-MM-XXXXX
  reason TEXT NOT NULL,
  details TEXT NOT NULL,
  
  -- Bank Info
  bank_name TEXT NOT NULL,
  account_number TEXT NOT NULL,
  account_holder TEXT NOT NULL,
  
  -- Status
  status TEXT DEFAULT 'submitted' CHECK (status IN ('submitted', 'under_review', 'approved', 'rejected', 'transferred')),
  admin_notes TEXT,
  refund_amount DECIMAL(10,2),
  
  processed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- RLS for refund_requests
ALTER TABLE refund_requests ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view own refund requests" ON refund_requests FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own refund requests" ON refund_requests FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Indexes for refund_requests
CREATE INDEX IF NOT EXISTS idx_refund_requests_user ON refund_requests(user_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_refund_requests_status ON refund_requests(status, created_at DESC);
